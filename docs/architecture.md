# Architecture & Working Flow

## Notarization Backend Working Flow

### 1. Backend Enclavization

The notarization backend is enclavized using the Gramine framework, which allows the application to run securely inside an Intel SGX enclave. The backend is packaged as a single Linux binary with minimal host dependencies, ensuring portability and security.

The process for enclavization is as follows:

1. **Enclave Signing Key Generation:**
   Generate the enclave signing key using the command:

   ```
   make generate-enclave-signing-key
   ```

2. **Enclave Signing:**
   Manifest file is signed with the enclave signing key and the signed manifest file is used to load the enclave. It contains the hash of the mounted files which will be verified by the Gramine LibOs in the runtime.
3. **Enclave Loading:**
   At first, Gramine LibOS is loaded into the SGX enclave with the help of gramine loader and then the backend binary is loaded into the enclave by Gramine LibOS.
4. **Enclave Measurement (MRENCLAVE):**
   Each enclave instance has a unique measurement, called `mrenclave`, which is a cryptographic hash of the enclave's code, manifest file, enclave memory layout and initial state. This measurement is used to verify the integrity and authenticity of the enclave before execution.

**Additional Notes:**

- The Gramine framework ensures that the host operating system cannot tamper with the enclave's execution or data.
- The enclave measurement (`mrenclave`) is critical for remote attestation, as it allows verifiers to confirm that the correct code is running inside the enclave. The mrenclave is also used to verify the integrity of the enclave during runtime.
- `mrenclave` is set in the aleo oracle program and verification backend to verify the integrity of the quote generated by the backend.

### 2. Initialization

- When the notarization backend starts, it generates an Aleo public-private key pair and the private key never leaves the enclave boundary.
- The `private key` is used to sign the complete attestation report after it has been serialized and encoded in an Aleo-specific format.
- The `public key` is set in the aleo oracle program which is used to verify the oracle signature generated by this backend during the attestation request.

### 3. Attestation Request

- A user submits an attestation request to the backend.
- The backend performs the following steps:
  - Checks whether the target URL is whitelisted.
  - Validates the format of the attestation request payload.
  - If the request is valid, it fetches the data that needs to be attested from the target URL.

### 4. Oracle Proof Data Preparation

- The backend constructs the oracle report data, which includes:
  - Details of the attestation request,
  - A timestamp,
  - The attestation data itself.
- The oracle report data is then encoded in an Aleo-specific format.

### 5. Hashing and Encoding

- **Encoded Request:**
  To generate the encoded request, the attestation data and timestamp fields in the report data are temporarily set to zero. This standardizes the report data for hashing, ensuring the hash does not include the actual attestation data or timestamp.
- **Request Hash:**
  A Poseidon8 hash is computed from the encoded request, producing a unique identifier for the request parameters (excluding attestation data and timestamp).
- **Timestamped Request Hash:**
  The request hash is combined with the actual timestamp, and this combination is hashed again using Poseidon8. This step binds the request to a specific point in time.
- **Attestation Hash:**
  The complete report data, now including the real attestation data and timestamp, is hashed using Poseidon8. The resulting attestation hash is embedded within the SGX quote to prove the integrity and origin of the attested data.

### 6. SGX Report and Quote Generation

- **Target Application Enclave:**
  Generates the SGX report and passes it to the quoting enclave. SGX report itself can't be used to verify the integrity of the enclave.
- **Quoting Enclave (QE):**
  Generates a quote, which is a signed statement containing enclave details, the attestation hash, a signature created with the PCK private key, and the PCK certification chain.
- **Provisioning Enclave (PE):**
  Assists in provisioning cryptographic keys during the initialization of the QE.

### 7. Final Signing and Output

- The aleo encoded oracle report is generated from the quote.
- A Poseidon8 hash of the aleo encoded oracle report is signed using the Aleo private key.
- The backend sends:
  - The attestation report which will be verified by the verifier backend.
  - The aleo encoded oracle data which will be verified by the Aleo oracle program.

### 7. Verification

- The verifier backend and the Aleo program check that:
  - The quote originates from a genuine enclave.
  - The data is correctly signed and has not been tampered with.

## DCAP based Remote Attestation Flow

The DCAP attestation flow is as follows:

![Aleo Oracle DCAP Attestation Flow](https://gramine.readthedocs.io/en/stable/_images/dcap.svg "Aleo Oracle DCAP Attestation Flow")

## Contents of a SGX Quote (at a high level)

### 1. **Report Body (from the Application Enclave)**

This is the core enclave information, created by the target (application) enclave, and includes:

| Field     | Description |
| --------- | ----------- |
|MRENCLAVE |Measurement (SHA256 hash) of the enclave code and initial state.
|MRSIGNER |Measurement of the entity that signed the enclave.
|ISV_SVN     |Enclave's version number (Security Version Number).
|ATTRIBUTES |Enclave configuration flags (e.g., debug, 64-bit, etc.).
|REPORTDATA |64-byte field optionally filled by the enclave (e.g., to hash app-specific input or nonce).

### 2. **Quote Header**

Metadata about how the quote was created.

| Field | Description|
| --------- | ----------- |
| Version |Quote format version.
| Attestation Key Type |Usually EPID (older) or ECDSA (modern).
| QE SVN |Quoting Enclave Security Version Number.
| QE Vendor ID |Intel vendor ID.
| User Data |Optional app-specific data.

### 3. **Signature and Authentication**

Used to authenticate the quote to the verifier.

| Field | Description|
| --------- | ----------- |
| Signature |Signature over the report using the PCK private key.
| Auth Data |Authenticated data (e.g., signature structure).
| PCK Certificate Chain |Public cert chain starting from the PCK cert up to Intel's root CA.

### 4. **QE Report + QE Report Signature**

To prove that the Quoting Enclave itself is trustworthy.

| Field | Description|
| --------- | ----------- |
| QE Report |A report generated by the QE about itself.
| QE Report Signature |Signed by the platform's quoting infrastructure (used by the verifier to validate the QE).

## Gramine Framework

This project uses the [Gramine Framework](https://gramine.readthedocs.io/en/stable/) to run the notarization backend inside an Intel SGX enclave. Gramine is a lightweight guest OS designed to run a single Linux application with minimal host requirements, providing:

- **SGX compatibility:** Seamless execution of unmodified Linux applications inside Intel SGX enclaves.
- **Security:** Additional protection against side-channel attacks and strong isolation from the host and container environment.
- **Manifest-based configuration:** Fine-grained control over file system access, environment variables, and resource limits.
- **File system isolation:** Ability to provide static `/etc/hosts` and `/etc/resolv.conf` to the enclave, ensuring deterministic and secure runtime behavior.

**Note:**
You do not need to install Gramine on your host unless you want to generate the enclave signing key using `gramine-sgx-gen-private-key` or run/debug Gramine applications outside Docker. All necessary Gramine tools and runtime are included in the Docker image.

For more details, see the [Gramine Documentation](https://gramine.readthedocs.io/en/stable/).
